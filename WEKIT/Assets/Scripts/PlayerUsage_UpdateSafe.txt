using UnityEngine;
using System.Collections;
using Kinect;

public class SkeletonWrapper : MonoBehaviour {
	
	public DeviceOrEmulator devOrEmu;
	/*private*/ public Kinect.KinectInterface kinect;
	
	private bool updatedSkeleton = false;
	private bool newSkeleton = false;
	
	[HideInInspector]
	public Kinect.NuiSkeletonTrackingState[] players;
	[HideInInspector]
	public int[] trackedPlayers;
	[HideInInspector]
	public Vector3[,] bonePos;
	[HideInInspector]
	public Vector3[,] rawBonePos;
	[HideInInspector]
	public Vector3[,] boneVel;
	[HideInInspector]
	public Quaternion[,] boneLocalOrientation;
	[HideInInspector]
	public Quaternion[,] boneAbsoluteOrientation;
	
	public Kinect.NuiSkeletonPositionTrackingState[,] boneState;	
	private System.Int64 ticks;
	private float deltaTime;
	
	private Matrix4x4 kinectToWorld;
	public Matrix4x4 flipMatrix;
    
    //Felix
    public KinectPlayer Player;
	
	// Use this for initialization
	void Start () {
		kinect = devOrEmu.getKinect();
		players = new Kinect.NuiSkeletonTrackingState[Kinect.Constants.NuiSkeletonCount];
		trackedPlayers = new int[Kinect.Constants.NuiSkeletonMaxTracked];
		trackedPlayers[0] = -1;
		trackedPlayers[1] = -1;
		bonePos = new Vector3[2,(int)Kinect.NuiSkeletonPositionIndex.Count];
		rawBonePos = new Vector3[2,(int)Kinect.NuiSkeletonPositionIndex.Count];
		boneVel = new Vector3[2,(int)Kinect.NuiSkeletonPositionIndex.Count];
		
		boneState = new Kinect.NuiSkeletonPositionTrackingState[2,(int)Kinect.NuiSkeletonPositionIndex.Count];
		boneLocalOrientation = new Quaternion[2, (int)Kinect.NuiSkeletonPositionIndex.Count];
		boneAbsoluteOrientation = new Quaternion[2, (int)Kinect.NuiSkeletonPositionIndex.Count];
		
		//create the transform matrix that converts from kinect-space to world-space
		Matrix4x4 trans = new Matrix4x4();
		trans.SetTRS( new Vector3(-kinect.getKinectCenter().x,
		                          kinect.getSensorHeight()-kinect.getKinectCenter().y,
		                          -kinect.getKinectCenter().z),
		             Quaternion.identity, Vector3.one );
		Matrix4x4 rot = new Matrix4x4();
		Quaternion quat = new Quaternion();
		double theta = Mathf.Atan((kinect.getLookAt().y+kinect.getKinectCenter().y-kinect.getSensorHeight()) / (kinect.getLookAt().z + kinect.getKinectCenter().z));
		float kinectAngle = (float)(theta * (180 / Mathf.PI));
		quat.eulerAngles = new Vector3(-kinectAngle, 0, 0);
		rot.SetTRS( Vector3.zero, quat, Vector3.one);

		//final transform matrix offsets the rotation of the kinect, then translates to a new center
		kinectToWorld = flipMatrix*trans*rot;
	}
	
	// Update is called once per frame
	void Update () {
		
	}
	
	void LateUpdate () {
		updatedSkeleton = false;
		newSkeleton = false;
	}
	
	/// <summary>
	/// First call per frame checks if there is a new skeleton frame and updates,
	/// returns true if there is new data
	/// Subsequent calls do nothing have the same return as the first call.
	/// </summary>
	/// <returns>
	/// A <see cref="System.Boolean"/>
	/// </returns>
	public bool pollSkeleton () {
		if (!updatedSkeleton)
		{
			updatedSkeleton = true;
			/*if (kinect.pollSkeleton())
			{
				newSkeleton = true;
				System.Int64 cur = kinect.getSkeleton().liTimeStamp;
				System.Int64 diff = cur - ticks;
				ticks = cur;
				deltaTime = diff / (float)1000;
				processSkeleton();
			}*/

            //Felix
            if (kinect.pollSkeleton()||(Player!=null&&Player.Replaying))
            {
                newSkeleton = true;
                System.Int64 cur = kinect.getSkeleton().liTimeStamp;
                System.Int64 diff = cur - ticks;
                ticks = cur;
                deltaTime = diff / (float)1000;
                processSkeletonFromFrame(Player!=null&&Player.Replaying?(NuiSkeletonFrame)Player.GetCurrentFrame():kinect.getSkeleton());
            }
        }
		return newSkeleton;
	}
	
	private void processSkeleton ()
    {
		int[] tracked = new int[Kinect.Constants.NuiSkeletonMaxTracked];
		tracked[0] = -1;
		tracked[1] = -1;
		int trackedCount = 0;
		//update players
		for (int ii = 0; ii < Kinect.Constants.NuiSkeletonCount; ii++)
		{
			players[ii] = kinect.getSkeleton().SkeletonData[ii].eTrackingState;
			if (players[ii] == Kinect.NuiSkeletonTrackingState.SkeletonTracked)
			{
				tracked[trackedCount] = ii;
				trackedCount++;
			}
		}
		//this should really use trackingID instead of index, but for now this is fine
		switch (trackedCount)
		{
		case 0:
			trackedPlayers[0] = -1;
			trackedPlayers[1] = -1;
			break;
		case 1:
			//last frame there were no players: assign new player to p1
			if (trackedPlayers[0] < 0 && trackedPlayers[1] < 0)
				trackedPlayers[0] = tracked[0];
			//last frame there was one player, keep that player in the same spot
			else if (trackedPlayers[0] < 0) 
				trackedPlayers[1] = tracked[0];
			else if (trackedPlayers[1] < 0)
				trackedPlayers[0] = tracked[0];
			//there were two players, keep the one with the same index (if possible)
			else
			{
				if (tracked[0] == trackedPlayers[0])
					trackedPlayers[1] = -1;
				else if (tracked[0] == trackedPlayers[1])
					trackedPlayers[0] = -1;
				else
				{
					trackedPlayers[0] = tracked[0];
					trackedPlayers[1] = -1;
				}
			}
			break;
		case 2:
			//last frame there were no players: assign new players to p1 and p2
			if (trackedPlayers[0] < 0 && trackedPlayers[1] < 0)
			{
				trackedPlayers[0] = tracked[0];
				trackedPlayers[1] = tracked[1];
			}
			//last frame there was one player, keep that player in the same spot
			else if (trackedPlayers[0] < 0)
			{
				if (trackedPlayers[1] == tracked[0])
					trackedPlayers[0] = tracked[1];
				else{
					trackedPlayers[0] = tracked[0];
					trackedPlayers[1] = tracked[1];
				}
			}
			else if (trackedPlayers[1] < 0)
			{
				if (trackedPlayers[0] == tracked[1])
					trackedPlayers[1] = tracked[0];
				else{
					trackedPlayers[0] = tracked[0];
					trackedPlayers[1] = tracked[1];
				}
			}
			//there were two players, keep the one with the same index (if possible)
			else
			{
				if (trackedPlayers[0] == tracked[1] || trackedPlayers[1] == tracked[0])
				{
					trackedPlayers[0] = tracked[1];
					trackedPlayers[1] = tracked[0];
				}
				else
				{
					trackedPlayers[0] = tracked[0];
					trackedPlayers[1] = tracked[1];
				}
			}
			break;
		}
		
		//update the bone positions, velocities, and tracking states)
		for (int player = 0; player < 2; player++)
		{
			//print(player + ", " +trackedPlayers[player]);
			if (trackedPlayers[player] >= 0)
			{
				for (int bone = 0; bone < (int)Kinect.NuiSkeletonPositionIndex.Count; bone++)
				{
					Vector3 oldpos = bonePos[player,bone];
					
					bonePos[player,bone] = kinectToWorld.MultiplyPoint3x4(kinect.getSkeleton().SkeletonData[trackedPlayers[player]].SkeletonPositions[bone]);
					//bonePos[player,bone] = kinectToWorld.MultiplyPoint3x4(bonePos[player, bone]);
					rawBonePos[player, bone] = kinect.getSkeleton().SkeletonData[trackedPlayers[player]].SkeletonPositions[bone];
					
					
					Kinect.NuiSkeletonBoneOrientation[] or = kinect.getBoneOrientations(kinect.getSkeleton().SkeletonData[trackedPlayers[player]]);
					boneLocalOrientation[player,bone] = or[bone].hierarchicalRotation.rotationQuaternion.GetQuaternion();
					boneAbsoluteOrientation[player,bone] = or[bone].absoluteRotation.rotationQuaternion.GetQuaternion();
					
					//print("index " + bone + ", start" + (int)or[bone].startJoint + ", end" + (int)or[bone].endJoint);
					
					boneVel[player,bone] = (bonePos[player,bone] - oldpos) / deltaTime;
					boneState[player,bone] = kinect.getSkeleton().SkeletonData[trackedPlayers[player]].eSkeletonPositionTrackingState[bone];
					//print(kinect.getSkeleton().SkeletonData[player].Position.z);
				}
			}
		}
	}


    private void processSkeletonFromFrame(NuiSkeletonFrame frame)
    {
        int[] tracked = new int[Kinect.Constants.NuiSkeletonMaxTracked];
        tracked[0] = -1;
        tracked[1] = -1;
        int trackedCount = 0;
        //update players
        for (int ii = 0; ii < Kinect.Constants.NuiSkeletonCount; ii++)
        {
            players[ii] = frame.SkeletonData[ii].eTrackingState;
            if (players[ii] == Kinect.NuiSkeletonTrackingState.SkeletonTracked)
            {
                tracked[trackedCount] = ii;
                trackedCount++;
            }
        }
        //this should really use trackingID instead of index, but for now this is fine
        switch (trackedCount)
        {
            case 0:
                trackedPlayers[0] = -1;
                trackedPlayers[1] = -1;
                break;
            case 1:
                //last frame there were no players: assign new player to p1
                if (trackedPlayers[0] < 0 && trackedPlayers[1] < 0)
                    trackedPlayers[0] = tracked[0];
                //last frame there was one player, keep that player in the same spot
                else if (trackedPlayers[0] < 0)
                    trackedPlayers[1] = tracked[0];
                else if (trackedPlayers[1] < 0)
                    trackedPlayers[0] = tracked[0];
                //there were two players, keep the one with the same index (if possible)
                else
                {
                    if (tracked[0] == trackedPlayers[0])
                        trackedPlayers[1] = -1;
                    else if (tracked[0] == trackedPlayers[1])
                        trackedPlayers[0] = -1;
                    else
                    {
                        trackedPlayers[0] = tracked[0];
                        trackedPlayers[1] = -1;
                    }
                }
                break;
            case 2:
                //last frame there were no players: assign new players to p1 and p2
                if (trackedPlayers[0] < 0 && trackedPlayers[1] < 0)
                {
                    trackedPlayers[0] = tracked[0];
                    trackedPlayers[1] = tracked[1];
                }
                //last frame there was one player, keep that player in the same spot
                else if (trackedPlayers[0] < 0)
                {
                    if (trackedPlayers[1] == tracked[0])
                        trackedPlayers[0] = tracked[1];
                    else
                    {
                        trackedPlayers[0] = tracked[0];
                        trackedPlayers[1] = tracked[1];
                    }
                }
                else if (trackedPlayers[1] < 0)
                {
                    if (trackedPlayers[0] == tracked[1])
                        trackedPlayers[1] = tracked[0];
                    else
                    {
                        trackedPlayers[0] = tracked[0];
                        trackedPlayers[1] = tracked[1];
                    }
                }
                //there were two players, keep the one with the same index (if possible)
                else
                {
                    if (trackedPlayers[0] == tracked[1] || trackedPlayers[1] == tracked[0])
                    {
                        trackedPlayers[0] = tracked[1];
                        trackedPlayers[1] = tracked[0];
                    }
                    else
                    {
                        trackedPlayers[0] = tracked[0];
                        trackedPlayers[1] = tracked[1];
                    }
                }
                break;
        }

        //update the bone positions, velocities, and tracking states)
        for (int player = 0; player < 2; player++)
        {
            //print(player + ", " +trackedPlayers[player]);
            if (trackedPlayers[player] >= 0)
            {
                for (int bone = 0; bone < (int)Kinect.NuiSkeletonPositionIndex.Count; bone++)
                {
                    Vector3 oldpos = bonePos[player, bone];

                    bonePos[player, bone] = kinectToWorld.MultiplyPoint3x4(frame.SkeletonData[trackedPlayers[player]].SkeletonPositions[bone]);
                    //bonePos[player,bone] = kinectToWorld.MultiplyPoint3x4(bonePos[player, bone]);
                    rawBonePos[player, bone] = frame.SkeletonData[trackedPlayers[player]].SkeletonPositions[bone];


                    Kinect.NuiSkeletonBoneOrientation[] or = kinect.getBoneOrientations(frame.SkeletonData[trackedPlayers[player]]);
                    boneLocalOrientation[player, bone] = or[bone].hierarchicalRotation.rotationQuaternion.GetQuaternion();
                    boneAbsoluteOrientation[player, bone] = or[bone].absoluteRotation.rotationQuaternion.GetQuaternion();

                    //print("index " + bone + ", start" + (int)or[bone].startJoint + ", end" + (int)or[bone].endJoint);

                    boneVel[player, bone] = (bonePos[player, bone] - oldpos) / deltaTime;
                    boneState[player, bone] = frame.SkeletonData[trackedPlayers[player]].eSkeletonPositionTrackingState[bone];
                    //print(kinect.getSkeleton().SkeletonData[player].Position.z);
                }
            }
        }
    }

}


//////////////////////////////////////////////////////////////


using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Leap;

namespace Leap {

  [ExecuteAfter(typeof(LeapProvider))]
  public class LeapHandController : MonoBehaviour {
    /** The scale factors for hand movement. Set greater than 1 to give the hands a greater range of motion. */
    public Vector3 handMovementScale = Vector3.one;

    public LeapProvider Provider { get; set; }
    public HandFactory Factory { get; set; }

        //Felix
        public LeapPlayer Player;

    public Dictionary<int, HandRepresentation> graphicsReps = new Dictionary<int, HandRepresentation>();
    public Dictionary<int, HandRepresentation> physicsReps = new Dictionary<int, HandRepresentation>();

    // Reference distance from thumb base to pinky base in mm.
    protected const float GIZMO_SCALE = 5.0f;
    /** Conversion factor for millimeters to meters. */
    protected const float MM_TO_M = 1e-3f;
    /** Conversion factor for nanoseconds to seconds. */
    protected const float NS_TO_S = 1e-6f;
    /** Conversion factor for seconds to nanoseconds. */
    protected const float S_TO_NS = 1e6f;
    /** How much smoothing to use when calculating the FixedUpdate offset. */
    protected const float FIXED_UPDATE_OFFSET_SMOOTHING_DELAY = 0.1f;

    protected bool graphicsEnabled = true;
    protected bool physicsEnabled = true;

    public bool GraphicsEnabled {
      get {
        return graphicsEnabled;
      }
      set {
        graphicsEnabled = value;
        if (!graphicsEnabled) {
          //DestroyGraphicsHands();
        }
      }
    }

    public bool PhysicsEnabled {
      get {
        return physicsEnabled;
      }
      set {
        physicsEnabled = value;
        if (!physicsEnabled) {
          //DestroyPhysicsHands();
        }
      }
    }
    private long prev_graphics_id_ = 0;
    private long prev_physics_id_ = 0;

    /** Draws the Leap Motion gizmo when in the Unity editor. */
    /*
    void OnDrawGizmos() {
      // Draws the little Leap Motion Controller in the Editor view.
      Gizmos.matrix = Matrix4x4.Scale(GIZMO_SCALE * Vector3.one);
      Gizmos.DrawIcon(transform.position, "leap_motion.png");
    }
    */

    // Use this for initialization
    void Start()
    {
      Provider = GetComponent<LeapProvider>();
      Factory = GetComponent<HandFactory>();
            //Felix
        if (Player == null)
        {
            Player = GetComponent<LeapPlayer>();
        }
    }
    /**
    * Turns off collisions between the specified GameObject and all hands.
    * Subject to the limitations of Unity Physics.IgnoreCollisions(). 
    * See http://docs.unity3d.com/ScriptReference/Physics.IgnoreCollision.html.
    */
    public void IgnoreCollisionsWithHands(GameObject to_ignore, bool ignore = true) {
      foreach (HandRepresentation rep in physicsReps.Values) {
        //Todo move this to HandModel
        //Leap.Utils.IgnoreCollisions(rep.handModel.gameObject, to_ignore, ignore);
      }
    }
    void Update()
        {
      //Felix
        if (!Player.Replaying)
        {
            Frame frame = Provider.CurrentFrame;
            if (frame.Id != prev_graphics_id_ && graphicsEnabled)
            {
                UpdateHandRepresentations(graphicsReps, ModelType.Graphics);
                prev_graphics_id_ = frame.Id;
            }
        }
        else
        {
            if (Player.Index != Player.PreviousIndex)
            {
                    UpdateHandRepresentations(Player.GetCurrentFrame(), graphicsReps, ModelType.Graphics);
                }
        }
        //Frame frame = Provider.CurrentFrame;
      /*if (frame.Id != prev_graphics_id_ && graphicsEnabled) {
        UpdateHandRepresentations(graphicsReps, ModelType.Graphics);
        prev_graphics_id_ = frame.Id;

      }*/
    }
        //Felix
        void UpdateHandRepresentations(HandList list, Dictionary<int, HandRepresentation> all_hand_reps, ModelType modelType)
        {
            foreach (Leap.Hand curHand in list)
            {
                HandRepresentation rep;
                if (!all_hand_reps.TryGetValue(curHand.Id, out rep))
                {
                    rep = Factory.MakeHandRepresentation(curHand, modelType);
                    if (rep != null)
                    {
                        all_hand_reps.Add(curHand.Id, rep);
                        //float hand_scale = curHand.PalmWidth / rep.handModel.handModelPalmWidth;
                        //rep.handModel.transform.localScale = hand_scale * Vector3.one;
                    }
                }
                if (rep != null)
                {
                    rep.IsMarked = true;
                    //float hand_scale = curHand.PalmWidth / rep.handModel.handModelPalmWidth;
                    //rep.handModel.transform.localScale = hand_scale * Vector3.one;
                    rep.UpdateRepresentation(curHand, modelType);
                    rep.LastUpdatedTime = (int)Provider.CurrentFrame.Timestamp;
                }
            }

            //Mark-and-sweep or set difference implementation
            HandRepresentation toBeDeleted = null;
            foreach (KeyValuePair<int, HandRepresentation> r in all_hand_reps)
            {
                if (r.Value != null)
                {
                    if (r.Value.IsMarked)
                    {
                        //Debug.Log("LeapHandController Marking False");
                        r.Value.IsMarked = false;
                    }
                    else
                    {
                        //Initialize toBeDeleted with a value to be deleted
                        //Debug.Log("Finishing");
                        toBeDeleted = r.Value;
                    }
                }
            }
            //Inform the representation that we will no longer be giving it any hand updates
            //because the corresponding hand has gone away
            if (toBeDeleted != null)
            {
                all_hand_reps.Remove(toBeDeleted.HandID);
                toBeDeleted.Finish();
            }
        }

        void UpdateHandRepresentations(Dictionary<int, HandRepresentation> all_hand_reps, ModelType modelType) {
      foreach (Leap.Hand curHand in Provider.CurrentFrame.Hands) {
        HandRepresentation rep;
        if (!all_hand_reps.TryGetValue(curHand.Id, out rep)) {
          rep = Factory.MakeHandRepresentation(curHand, modelType);
          if (rep != null) {
            all_hand_reps.Add(curHand.Id, rep);
            //float hand_scale = curHand.PalmWidth / rep.handModel.handModelPalmWidth;
            //rep.handModel.transform.localScale = hand_scale * Vector3.one;
          }
        }
        if (rep != null) {
          rep.IsMarked = true;
          //float hand_scale = curHand.PalmWidth / rep.handModel.handModelPalmWidth;
          //rep.handModel.transform.localScale = hand_scale * Vector3.one;
          rep.UpdateRepresentation(curHand, modelType);
          rep.LastUpdatedTime = (int)Provider.CurrentFrame.Timestamp;
        }
      }

      //Mark-and-sweep or set difference implementation
      HandRepresentation toBeDeleted = null;
      foreach (KeyValuePair<int, HandRepresentation> r in all_hand_reps) {
        if (r.Value != null) {
          if (r.Value.IsMarked) {
            //Debug.Log("LeapHandController Marking False");
            r.Value.IsMarked = false;
          }
          else {
            //Initialize toBeDeleted with a value to be deleted
            //Debug.Log("Finishing");
            toBeDeleted = r.Value;
          }
        }
      }
      //Inform the representation that we will no longer be giving it any hand updates
      //because the corresponding hand has gone away
      if (toBeDeleted != null) {
        all_hand_reps.Remove(toBeDeleted.HandID);
        toBeDeleted.Finish();
      }
    }
    /** Updates the physics objects */
    protected virtual void FixedUpdate() {

            //All FixedUpdates of a frame happen before Update, so only the last of these calculations is passed
            //into Update for smoothing.
            /*var latestFrame = Provider.CurrentFrame;
            Provider.PerFrameFixedUpdateOffset = latestFrame.Timestamp * NS_TO_S - Time.fixedTime;

            Frame frame = Provider.GetFixedFrame();

            if (frame.Id != prev_physics_id_ && physicsEnabled) {
              UpdateHandRepresentations(physicsReps, ModelType.Physics);
              //UpdateHandModels(hand_physics_, frame.Hands, leftPhysicsModel, rightPhysicsModel); //Originally commented out
              prev_physics_id_ = frame.Id;
            }*/

            //Felix
            if (!Player.Replaying)
            {
                Frame frame = Provider.CurrentFrame;
                if (frame.Id != prev_physics_id_ && physicsEnabled)
                {
                    UpdateHandRepresentations(physicsReps, ModelType.Physics);
                    prev_physics_id_ = frame.Id;
                }
            }
            else
            {
                if (Player.Index != Player.PreviousIndex)
                {
                    UpdateHandRepresentations(Player.GetCurrentFrame(), physicsReps, ModelType.Physics);
                }
            }

        }
  }
}


////////////////////////////////////////////////////////////////


using UnityEngine;
using System.Collections;

using LockingPolicy = Thalmic.Myo.LockingPolicy;
using Pose = Thalmic.Myo.Pose;
using UnlockType = Thalmic.Myo.UnlockType;
using VibrationType = Thalmic.Myo.VibrationType;

// Orient the object to match that of the Myo armband.
// Compensate for initial yaw (orientation about the gravity vector) and roll (orientation about
// the wearer's arm) by allowing the user to set a reference orientation.
// Making the fingers spread pose or pressing the 'r' key resets the reference orientation.
public class JointOrientation : MonoBehaviour
{

    //Felix
    public MyoPlayer MyMyoPlayer;

    // Myo game object to connect with.
    // This object must have a ThalmicMyo script attached.
    public GameObject myo = null;

    // A rotation that compensates for the Myo armband's orientation parallel to the ground, i.e. yaw.
    // Once set, the direction the Myo armband is facing becomes "forward" within the program.
    // Set by making the fingers spread pose or pressing "r".
    private Quaternion _antiYaw = Quaternion.identity;

    // A reference angle representing how the armband is rotated about the wearer's arm, i.e. roll.
    // Set by making the fingers spread pose or pressing "r".
    private float _referenceRoll = 0.0f;

    // The pose from the last update. This is used to determine if the pose has changed
    // so that actions are only performed upon making them rather than every frame during
    // which they are active.
    private Pose _lastPose = Pose.Unknown;

    private ThalmicMyo thalmicMyo;

    void Start()
    {
        // Access the ThalmicMyo component attached to the Myo object.
        thalmicMyo = myo.GetComponent<ThalmicMyo>();
    }

    // Update is called once per frame.
    void Update ()
    {
        //Felix
        //Transform tf = MyMyoPlayer != null && MyMyoPlayer.Replaying ? MyMyoPlayer.GetCurrentFrame() : myo.transform;
        Transform tf = myo.transform;
        if (MyMyoPlayer!= null&&MyMyoPlayer.Replaying)
        {
            transform.rotation = MyMyoPlayer.GetCurrentFrame();
            tf = transform;
        }

        // Update references when the pose becomes fingers spread or the q key is pressed.
        bool updateReference = false;
        if (thalmicMyo.pose != _lastPose) {
            _lastPose = thalmicMyo.pose;

            if (thalmicMyo.pose == Pose.FingersSpread) {
                updateReference = true;

                ExtendUnlockAndNotifyUserAction(thalmicMyo);
            }
        }
        if (Input.GetKeyDown ("r")) {
            updateReference = true;
        }

        // Update references. This anchors the joint on-screen such that it faces forward away
        // from the viewer when the Myo armband is oriented the way it is when these references are taken.
        if (updateReference)
        {
            // _antiYaw represents a rotation of the Myo armband about the Y axis (up) which aligns the forward
            // vector of the rotation with Z = 1 when the wearer's arm is pointing in the reference direction.
            _antiYaw = Quaternion.FromToRotation (
                new Vector3 (tf.forward.x, 0, tf.forward.z),
                new Vector3 (0, 0, 1)
            );

            // _referenceRoll represents how many degrees the Myo armband is rotated clockwise
            // about its forward axis (when looking down the wearer's arm towards their hand) from the reference zero
            // roll direction. This direction is calculated and explained below. When this reference is
            // taken, the joint will be rotated about its forward axis such that it faces upwards when
            // the roll value matches the reference.
            Vector3 referenceZeroRoll = computeZeroRollVector (tf.forward);
            _referenceRoll = rollFromZero (referenceZeroRoll, tf.forward, tf.up);
        }

        // Current zero roll vector and roll value.
        Vector3 zeroRoll = computeZeroRollVector (tf.forward);
        float roll = rollFromZero (zeroRoll, tf.forward, tf.up);

        // The relative roll is simply how much the current roll has changed relative to the reference roll.
        // adjustAngle simply keeps the resultant value within -180 to 180 degrees.
        float relativeRoll = normalizeAngle (roll - _referenceRoll);

        // antiRoll represents a rotation about the myo Armband's forward axis adjusting for reference roll.
        Quaternion antiRoll = Quaternion.AngleAxis (relativeRoll, tf.forward);

        // Here the anti-roll and yaw rotations are applied to the myo Armband's forward direction to yield
        // the orientation of the joint.
        transform.rotation = _antiYaw * antiRoll * Quaternion.LookRotation (tf.forward);

        // The above calculations were done assuming the Myo armbands's +x direction, in its own coordinate system,
        // was facing toward the wearer's elbow. If the Myo armband is worn with its +x direction facing the other way,
        // the rotation needs to be updated to compensate.
        if (thalmicMyo.xDirection == Thalmic.Myo.XDirection.TowardWrist) {
            // Mirror the rotation around the XZ plane in Unity's coordinate system (XY plane in Myo's coordinate
            // system). This makes the rotation reflect the arm's orientation, rather than that of the Myo armband.
            transform.rotation = new Quaternion(transform.localRotation.x,
                                                -transform.localRotation.y,
                                                transform.localRotation.z,
                                                -transform.localRotation.w);
        }
    }

    // Compute the angle of rotation clockwise about the forward axis relative to the provided zero roll direction.
    // As the armband is rotated about the forward axis this value will change, regardless of which way the
    // forward vector of the Myo is pointing. The returned value will be between -180 and 180 degrees.
    float rollFromZero (Vector3 zeroRoll, Vector3 forward, Vector3 up)
    {
        // The cosine of the angle between the up vector and the zero roll vector. Since both are
        // orthogonal to the forward vector, this tells us how far the Myo has been turned around the
        // forward axis relative to the zero roll vector, but we need to determine separately whether the
        // Myo has been rolled clockwise or counterclockwise.
        float cosine = Vector3.Dot (up, zeroRoll);

        // To determine the sign of the roll, we take the cross product of the up vector and the zero
        // roll vector. This cross product will either be the same or opposite direction as the forward
        // vector depending on whether up is clockwise or counter-clockwise from zero roll.
        // Thus the sign of the dot product of forward and it yields the sign of our roll value.
        Vector3 cp = Vector3.Cross (up, zeroRoll);
        float directionCosine = Vector3.Dot (forward, cp);
        float sign = directionCosine < 0.0f ? 1.0f : -1.0f;

        // Return the angle of roll (in degrees) from the cosine and the sign.
        return sign * Mathf.Rad2Deg * Mathf.Acos (cosine);
    }

    // Compute a vector that points perpendicular to the forward direction,
    // minimizing angular distance from world up (positive Y axis).
    // This represents the direction of no rotation about its forward axis.
    Vector3 computeZeroRollVector (Vector3 forward)
    {
        Vector3 antigravity = Vector3.up;
        Vector3 m = Vector3.Cross (forward, antigravity);
        Vector3 roll = Vector3.Cross (m, forward);

        return roll.normalized;
    }

    // Adjust the provided angle to be within a -180 to 180.
    float normalizeAngle (float angle)
    {
        if (angle > 180.0f) {
            return angle - 360.0f;
        }
        if (angle < -180.0f) {
            return angle + 360.0f;
        }
        return angle;
    }

    // Extend the unlock if ThalmcHub's locking policy is standard, and notifies the given myo that a user action was
    // recognized.
    void ExtendUnlockAndNotifyUserAction (ThalmicMyo myo)
    {
        ThalmicHub hub = ThalmicHub.instance;

        if (hub.lockingPolicy == LockingPolicy.Standard) {
            myo.Unlock (UnlockType.Timed);
        }

        myo.NotifyUserAction ();
    }
}